<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>KhaosRevelation | PornLeaks</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">PornLeaks</p>
                        <p><p>Pour avoir acc&egrave;s &agrave; cette cat&eacute;gories il vous faut le Vip Ultime.&nbsp;Vous pouvez aller voir les prix sur le lien suivant&nbsp;<a href="https://www.khaosrevelation.site/vip.html">Prix VIP</a></p>

<p>Revenir sur&nbsp;<a href="https://www.khaosrevelation.site/index.html">KhaosRevelation</a></p>
</p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Mot de passe"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="AccÃ©der" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = 
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "template_error",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3c78e9bdea46edc9185bfe653eeb3aef64bde2f70994b43b0fbac3ba580a56a92c7c204c3f2ab0b07ee3f95606ab675652c8c418e2363b74a9ba234b41be6deeb1fd3e5ab1baa8e711ec0460e9e3735eb54b6b4a67a02b24ac9d407908642b9369678166e4c742701c88e39ef1fef4897ac3a97a212957bca22ed5e993929f66344062f5cdeea0bb64bd2f4ec3641be0a92117a35ebfb1899753bd0b603f1ace6a3761053a8d1a25096a01bfea1f87478d3022e5e8f6ca2d499c8001674f13bd1d64b83c554a8c467806c80c9cf84161e873731dfc9b3ecd94526b0f5ab65931b5bc5ebbbaf6b571a7274ee4ae5ea399ed9c7129199bbe1c99749393846e02b9a036bb2ce750fbabaa966dd68e1f45df6a064922b6e07500878ed0c1e3abc5564afff4e818e3412b05749466d130c4ccf7bae14b706f63797920a453c8c1c7a552395d0b394a63ed9a6e115a51bf74e96f7d6b3d248d88cbc0978961306fb665ede2036aa166c8f04142ffc0a1af312fa6e4d034cfdbd018fcca440008091a9962f55acca21c81bb743457faa51d9654e67b65548285c44455f36cecd4110250968af86e889f880e52e763a6ef6319dfe134db38de8674379403f8d513f18c1bc2fa5864e2d4478e5ecb863dd01c01ae5afb85a587ccc4f7d0eea96ec7a7296fa08623afb9aa012fc464a4dcb3bf05d2b01cd9e186ed7ba9648eb9b4e2398cb406e8d3b611b35ad5b7bfce52c2ee4b5a5dcaee638446f03ca27af3035afa3fd6902e0c2f2b197ea0c4c483a387b079e7b69b87ad642bdf573d5a3d9891e86a7751277b074ef1c36b5345de3fa0c4cb25a8a890dbe182902c269f079851b8949c5722ab46678bd3a88456d486adfac594ca19f21b842257e0c6d1896a949d7d6110cbcc55651eb807fdb1cc6bf4d321402658377d5345064a5f1139ceec7fd17854d9612c8205c2199dae4b50f2f2e486721a1eb41f7892f0eacb35c7bdef4e9cceeed1d67f1e1409be5cfdb2c7f0fbdad5b372c0d194313ee3ae62481ac66c8a36c6da508aee460e95e42ca0b277c81ab272a29c1ff113686bf4371a8eb56fb6756329f7c7ef47b6ddbbabf9d511b75a44205f31bd0070b70135978a119befd446622733c49a90ca0e190aad4036a69451067280b0af631f96bea2ce309e2ea96f5a310d1d90e828fb665ad7ba0fe0de4c49a6d75f54025d11625aa74ff3b6a2a317dc0812232725132f110c1d18535faa89974d17aabed27e2ceb7420c430d29c5ff5b59059b803da65184267bfbb5b647661867559bf177db78f80bd732e7c799cfa8352c6b30144b508ca601f37ca0f82d91f72083c1bd3f01347782ab406d3a7a449d7098ef2f9d2dfd2bfea0ec0ee7ce3b8931c0703d1b0ad3376f652b237f9813750a5c4d7d983f0cbc56af95e2918a1ef579600146b3eae5199afbc01fed279714e0b52f5722ea138e1ee28b4d748ca73b76101b9af3207277362c00998ab9f0c491bc9b9276c2ab8b8f4011b9cfd33183550daad9efb337f3b1fbe8ef8614d9700410a47c75c9d487559997e84df6304254491980402172ed7e2d365ec038648152bbbee289c6b44af45fcfdd5e825d4a50bbb0ea96f99eae6c5751f36db00fe71328620e01507b035ae5eac6b49730a2b01a85fbd02ba88817233a4515f0d6def60c3fdafb859abfc2ea81391e2d2a9aea42947a07dc2687c8919a33c2cb38d1c9c98887a83eee0440e44703c5acd1b91bb63ffcec0c9f787a3c305cdbccdb8dad981e49abc26040bccc5c3d574c816df56eef2960b7f935e425f5d1084910a19b5ba657686e6cbaa41ddb41cf01784ecdaee3ad50d6329056b968b27afaef154775102e879cabbe3e35ee705d309824dd85ed31bfcebea1e00ab8d09a9573cc690633c6e6b21be5d2228956024a4828ec7b9e7e065830aa8e822da8a2f2428bd0270ce785f3c00f966442716a4e332fb515fbc848cc51756e079f867bfbf87aa3643e68e88b78b99a6c58f64d91ac16963dc31bf23b150298327888d92c437faff8fcd5dbea5b7d91b4ee2b44a466afbaba44293013dd8ce23e6d3c2c752ec29e74c57fe758644fdd1323e656c8ad74afbf0efb2f9f67f81a128f469c6f993ebcbf47d7c39caf3fe563cf38d48e4065c3110377cbbd39319e1cd73477dc994b37e9aad89a1872ed35d2a64d79aac4adfbdd846f3ebaea2db97c6a959541126dce1f22c8d24af5311ad8b01b9d5c808bc831cae8b9ec3e41a49c9c684507685e9910cbca477a4487ca72c5269b10f72d3e2355fa29dfdd6e9c7304c82c2b15c843ca764daef41899dfd09e2b0dbc6a89b9f039625ad9bc0a80d05951d5e621c27e8cbd731c80eae1d7425e5a856d8e30a97ec99db4bc0719c1c61e6e7795f1c77609e794212c8bdb66b3dfdcb967f286f0a2b8be426012d55580eeee493ebc7c6b81c7682606a073824aa5aae2b97be452352571a5f68eca1bd0145763e669622fefa9068145a2a5b8265d13038e64acb267491b879b349d75cc726f0d32bffcbf2739b9fd2d63e0e642057f1a70529e4c095af5dab2a7aa5fcbbc67d37a7cfbeaa440b3ed5c2115d3c935e7dd5396881f617c1bfb43feafd7f5d589f17096c3dc86b763e8115d3cb0bbd43df056e0a7d1fea8ed224ac21c08a8c9134e8ff7b1ec37d808f6127c9852213b0bd6f6111f2184a10d9db5fd3f6ee84a3792f4b86fa0dc0b581fff229d4b6a1c493bb95f52ea13e2a256f59d8cd86731ed98478bd3e8409b1910a838683d925de82d6321a3fbfca2f3bccdfb8578ead3968db11ae31d1145c30bd98fb593dae30fdd9f3f0813216c17eaf190155fcc53221fd125db10ce98c219f10f338cebe73c552a5ece4f572710e60cb6f33ad02c718c1eb721ec292d66a2e98ad7322df7e938d69f8b80a1cd696f96aaddf0b6d5fca8e2875caaf371cb2463a60e751b9ce86cd50c42424677618736bc99afc466a1458c8ea91f8d3f24059ed16c83fb4018f1a413c0ac2559ee57f242e151526451269cee6fcf74075a4d92aebc1590dad83e5edbefec0310c8a315f2bfee90e16c173315e225dc20b86ad741683d04d3bc88b0d3b47d89b7a595433f01c3da80ca8005acdcfce85bd02b8f8e5bf076852456ba567c6d3689fa65bf67aa91a607d6b4b6c14fdbc877625cc3f1277d3941a86ad810652acab4c544217dd8a0c13443cf40cfc31ecaf4ae97e2b1930c4aa915d60b2249ab2761e573aca94a747543096c92203f39dfef07b2e3e0a5ea1851b91bd3ffb7508797d3fa0970bd71feb87e191ba91774e80aff0886167d87cb1c6f26827695e101089dfaaa875f35f68ae09828310f805c74afb01538b6308d8ccab2688793e12c99acca15c5281e430cf435c8c2d88d94ade1e026970e2b90900f60033acd90a49c41d0ce28a60bc17bb3bc7918913cbd53b7190f10d1a06be801a0c719ba0daf20157c710dea05fabf223160b6fd8469a53c51d0696cc10e1c179405a50d37b5cbd12f0b3bf2569a1063074c7490776663f22ec5e1be241160ece9c014bc0f3bf0fdb6f2b2f97f09340d0e5e8d7a8d970a913c35a78bc1555fb62055c63690f9b1f59bab79c9abb137d37f5ab4d2fb71dc58f4628e41dcf572cf514aa9e271c462d1d90d267b4df9d0ded40f582396834f43b53af72787a42db1caf6b73536aa7e72173f44391d2393e0a23753c8410d401939dbbd6f99410a46fffdae98b0e6f9708e573252909dfc8bf6b47702adf0652eb090b544935eaf9f8e8b4ce5a59e33a54cc99608674211f9068b63cd8d90191e40c13d183dc46bf8d3d896f51bbdcf62d6903bfd136c928a45a3e4572dc32f47e8ef5580003759528539ce9aff950e4c2bb079230a4b391aa4ba86f2a7a4e0aa2b59307b06e573645f076bc5347f303644e9649692e91e26902cd4bd25a742c4c71a6867c29f9e4767578e214273ac214ea1ff1fa1ad03e844c384d26af179cd6e01ddaeb30728504208a724e87bd5c5edbbe4c7690ea2957ac7024a9727eaae0a517bb9c73bb0429a199196a208720990ce497fb384f02bc6f364ed3d4e3cca1550cab9267f2813547134de3f8387ad62796e0d9f15a7b666b3cedf9776a63d3498e455cecbdd69a0d24935afca4a4cc5f4e55ed56e2c55b8efad8ce6221e7d6d07d822c8df6020f7ed154667d4eccb6b083eb2aee913ab119b9b584642c414c7376ac10972c8e064bf9f7507a94020efa5f13bed5df3aa236644f9c4eb73a0da23d12369b2d740d8d737dc0b0ee8b81da0975564ef1fd8b744e72ce9217aae2a227023f7b7b47fd7fe60eb402b72af60932e805e739d30d071387966a609185445934b60f2d3ceaf36dc00550d3105f3a8730375a682a143d061e0f97d8e10442bc740c49240e3c9a3619386cc9cbc42db70a9e728934a7d19ca30f8935a267266fca9796b75e24f7665a7aaa3b501ecb49b12c4ea9408af57b7e26c39b3ba12fbe15552fb8acce7e7e098aff112417db8b3334a602d1ac43d45b41e9de86c88ca8359b0018925492d6cb122b469554ee3ba016040777a9dbde488ce1658de3433fc39090c9ec46937ebaada77a1c681160e7a4b7e2f8c8735a883ab08c5922e6a26b3d35498f223da75bb5896db051cc5c34732778b67d20228a7cb716aa862d189bade84bff0d1bea4f0292ad8f0c141fd4e7a81544db0b09f24c10eaf091d657402f83b502be8c211e85ebfeafc09840c306e05022c38161299f009f4ac70696eaa31ba4798ca4d89cd2a0a1bcff1f5138f6123f114a316f3a0a5d5887f2bc4d7ca5a287c95bac2f2886744e78243c98c20baa779d93f212f070d13905df5983784663eeccd77aca882a62d3548a2be891704514661305afd2acd83ad3f03f71359096297f0fbb295fe99cf95b921ad0682dd9b8dd51dc18b7a89d0be15bb06725c1b7aeb054271d4a58602043d8c578b67ac3592fc2c4b1ee0ec46f6c7b329f1e16f451074e53d8b70a19265f4b98cbaa649f22335a1da15f4a5244da5300451c779e9a2f4d1d73b2576fb33ef7345a90922d33935aba82c0ba7e402b6e7910c0aeb0f77b78fd280615e35bbb2caa70d31c4e3f5dfcf460fcdb862ce6de6c07c1f29ec94ac533e057ad5eed303cb649ee84094886762f5003613767ba6a5721ad96a6dfa3707315fe0ef91907fa2c5a8bead4104bea1c63a463cb6259f73e9f81070364b55fec92efcd0591ac74381e8f981361527b8af8b706a12d622addc5e4bf82d155987765a192e5a5c81fcec008cbaf67925b82f3c1294983ec1fda1f57b7bb0366be73269f07631f3180e7f969d27bd621573b5e680142140926d7d6331f4766dd72f7638ad30a0e1f5fa78720fd37d17b11e6dbd0d99df3cf0f06b4a537747db7d97e2fd7e02d3a1802a393ecb24af2728b2cb8a4a13e82be5afd7be198ad11db0edb8076db7e73e332ecfe3bbaf187cb6a27e1b9e45e6573068f4cb4e47867c31282dae29c38565bd8bde31fc82d6cb3221f2c4773054e1eae8a860f42570eeab09c83419ea2539f595cba445d389535faa7a72cafbcdf233eac5864398b497e5afc18cf7841961c42eb4c63c6b8fab1b70ed4be68d7106f9eca2901ca36d8fbebaa67839f63782c0bab9cfec48562e7756756174015507a3894be0213affee331ad0da45c1d29de6d58a195998c3df2013219ae522860631764ec7428ef4fac5279dbf764fb63fa192c2a3d0b437b41e08b3bb03dcb2f69eb77e9e0d63b7fc1bdded562f2b0e54e459c34cec21257f6eed21dd9dc70556ee7c5357731be1b24cc876296ea89e0ab219fc22c2946f7d48605d3a30758ae399fe48033389f707860ed3ac9a31fdaad2b1e287459ff8f65baf11ab7645fbf97d3eb877e9bdc04ce36bd50977d1b1118a28e79c578b8405a5a951d550aea2d68ba914468d5000b3de4b2331a9fbe4f867cef533459d72f1c146378c5ac58b362dc46181df860a5c9a8b5802ebd332de41c47cef480b00a87957c5f8e531a3f3df904f2cd6e9a27bfdb3299029a9ab1ddb8a5342a1ad2cf212ca7121489561bcb07e49157209a3c403aae62ab7cfbd5b41c1f47b5d83d2a9cbc7906ddd576412cb161624c042b90a6236eb5a5088e6f8fff0b544d0d9b98c8378b8bc5e2ff0d8da0ac5efa64499f2c7c53fa92b1a258e949173bf36110237f021e60cdef504b2a90f0e4032e0c6283716b88ad9257fcbc3d02ce3f018ff661d28605932f36d6e932f2bb39ab7b41725f2f43bf09ba65bb6da1b2834604432767fe05673c4eaebd30f1f170bc3f62f78fe105e991a48762f17a21db7c58d18121a8a23cdec5fd052a67755a51ad7b6c3bc6c25a49c55e5cb482fbaa691e6134d4e0f2226d5ee54c1a97670a3af87b1513c2a2ff53b24400cbdc26adc8d871016769da5f82493aae59a6d5b003b76e44e49c7d76f22639d05484623fcc8d00634f0b3d536a2ab8c982ebba1cf84fc580ba11fd12cb4cef89699e42590bd807653c7144c7eb7da3b54340e62f8028cb2b84d6d655ea1d9d641f9dea834f537ce0c78b86017d5f9a4e449df1e1c8762faefba26bc56f935f5a753c57f98846a6268d0d5393f2b7a529c1ed7275ec96f3445d49e61f0e163d8ba6185a25fb167124a6a68ebf1d7a362894dfcdc4dedafca1acdd7b93ecf4edd3fee740a99209bab992ca294a4d95d4c471f300669eaa2aca8dbc85e7b4bf96c6ca2232cd21402b741fe945a67d3ed44590cc2de68b528842257ae737a8fb602c4efeacf2c09a317f97c3fc85e2132795f9821cdd45716eb55fb5398131752380ebb7f92b0470f3af47aad9a28a5419c306c3927a7ed557aa7e208626d387cda12b1871bceefa9d5eade3ed0221d3764d549e0a9b1fa6c2a6dd6b5a3c8e2965640a520f9d16a95234e2a6262fb049ac18a7c452c289b3f025b7bb7ad86b06838beab2d27b135ea76e2e75e15504c439d4e6143197634ca144a56af89878bd3c6bc1d785b176fe7edf83d03ccdabfdebc5d980bdaec21dbe7e38a41b5df373b146ad0d37579e45d68c6e8033df84e493573faa739b517569ed2e5932a48dee5c8cf3aa11804b7a9656727cde7e46ba8eff99ddfbfa393608e70169d6ae98a965fe69bc3de9f25b8a00f4de9cd4f65be69c79e433ad4e72a3e8cba9e24e9a1df7906c5d644a5e056ec01ea0acf2b064a140f006a021c2e5f3355b255ba3b0702c019f5bdeadf27b45296a20790b0574622555a754b4e93e992254a0b3490fdd71fa521e22a7b9ac423ca1ace6b615365768d5f090026d6f9af988167288710779ed2d2b8df49b2c104d73785a72c4430c61a2d44f8824dbd4bbfceb88a41ab1f2a29b0752b03e2c9a4dd53859e53ffb6d7e2a45a3a7b95707de8799d83e904e3aaabebef2647045b98420cdd1d4a0177e23245be57c056d14194bda0cf96cad5057568e9927aa89aea56aee18dddda59eab219addfdc18e34244a475427398da62c164dc2e37529dbf94fde96873370ecc3908a7b0089bb8f623cb6adc1a0a7b68097dac69a3160cd4b0aa7dd4f7904b0fa1a98b72615b2191b5e521eb08152bd05192e48322797ff2bccbed95ec29e988b80074637859a588df78906ebabd03b3304734e27d3a6240ed6b432b3239eedfa2c39c3f644318cf8aa6c5a824b693386836afa2c5b229ea9d7c3000c30057a63af73c1b4edb6150541757622ebcc08498ba133a5ed11d73018b8e88134711889f6863c5776997a66813bf73198c6704f587281320204cc86475fe378908cb0fd52129ad46c2eee922cac5e9735927214212aa2811b2e1d413763025ef4d55e6c59889e491acbbbc967f7cce0a8cb8f8848cf611029c2edfc9717718824dc25cbcebaf75722f0bb3be357e7da17e484597a5678460dadddf48645a8199c1c7ee37e91241c6f4fd3e86dcd3c427a6de5b742e724eb24be9a11c479edab920312a83ecd25977cf14c0270a80bced6ba1fb352d0bc0762430b525a82ee7fff04118cdfc76314211345f33abd6158c8eee2e322f184ed2d3fec8b1bc70ae0e414f46477af392d858266686fffb68cb164bf530e1684bafc7ba4f0671cf032405b8f2ee864f076fafb06ae2184bbbb3191f3059b3ad79989959f1805ab76c5a74638de035beb9788a5f41da6ad19972c74b557a426cc1c195df869c5b00caf386596794d967b858fa0a4c47d1302aa1747252e9631e12e74eb534095a00c94f779cf4ea61bb41401ef434196ee620a66b80989b9945918f57182ca2938b5d3302a409a50524118305adccadaaaf5a00b89f670408087b0fd6b9c2fb2a812b8661b1a17876d36af498663e11d00ddd95a1233094328ff67d79f751ba55bfb7a0c8e0612c49b13789322e6f2ba4d6037c6631f529d964bc560d6adfe1fc7673471f9b6da750faf77ef801616147a1897a19d6ccfaef1bfd13ca467e03bc534a02b84ce4364c86a711abe2b2809b6e7a996a3c651ec74b45d0ddc876b1e9bbf211d282dedf1707aa6f5344b716f45ad775db1fa1aea92ddaa04773a551f558aff7cdda1b6be477fcbaa7aad7f5a9ba949e70cddf110277ef070a85d30f97e65739bc4a5c12b5ad56e17c6c5a97eccb3c9159612d8db43663eaa62c8dcfe7be916480abba4c5c4a181f451bb32e354c99aff9a38598acbc760db4cb56e1115eddfce08c11cc197ae1cc04199a7f27779de91d9240909b77d08f9e2ef52ec150f7d5193e8ae2a86e0c84f7815ccbdc222294284a8132133b9bc90743515a81248b83a7f6cdb61da4b09d76e4f2470f92c687dd7e7657e8c63d8d16f221f51033b08e0af14f9296d589033b2308f70eae4fb6196934e42aef878c02fcb143d3a8633ad711764fc908cca39639e1a86c6781f9366516242254c6e873d946a59f148bbf13edbda4ce992dd9fae36500f32870942316c38290f9643cb7addb4d87156f5e88cba7325df8044b6dc71985e82d30c10eca6c20c0cbdfab2c025efd6fde3d9a74a4b04e4f2ec3feb73b9f2ef58366c5a3c98bf012760c0971e275fbb89bddeb23d87193f882f80a725c8111ef822389ddd666b733936e0ce1e60a0cfb1ec48bc89ff14461f7780c8b7ee8f0350862447f128717d5b073ef57a854d27cd59ba8eaef7e5db75e792ad33b0c5ffc3aca4818f5d80ba5f9f847847a6cebc8a1e148899766922792631eb0c86bfbb8b8c39ce6e0540e2c65121c875dd599f46a040889a4408676ecaadf1dafb03c2a0e24fa3ec79888fb48c478414aa7f5f24aadf4277ceb637769207de638aefc838e91e9e03d72c1fabd8bcc81ca30b1e4bdf9fd8bbe91db8473988bf2ba3d2a3dcdbd3605049850644b2abb45f43c5c0874d531b4f6242a8ae61452e5e9f8a6556703bcf6d4856c7df5b48ff5b44f6b65d80629296f2632f96d950a572d3ffcfac36f9ff382530905bf0a57af0b99c67bf1ab657dc7da0e10586fbd7c2140849148201d7bf92238d8122efe4e915d3a84c3c0f955ede117292be312fa68f1034c50b9240d59ce7225c10231f1f718fd065286335469408150d029d42cb5508cf742bb42408f1610596d816f95f5690","isRememberEnabled":true,"rememberDurationInDays":"30","staticryptSaltUniqueVariableName":"3cbb8084e6b6d8d7618bf616e3580beb"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
