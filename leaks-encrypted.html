<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>KhaosRevelation | Leaks OnlyFans</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Leaks OnlyFans</p>
                        <p><p>Pour avoir acc&egrave;s &agrave; cette cat&eacute;gories il vous faut le Vip (ou un grade supérieur).&nbsp;Vous pouvez aller voir les prix sur le lien suivant&nbsp;<a href="https://www.khaosrevelation.site/vip.html">Prix VIP</a></p>

<p>Revenir sur&nbsp;<a href="https://www.khaosrevelation.site/index.html">KhaosRevelation</a></p>
</p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Mot de passe"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="Accéder" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = 
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "template_error",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0bb283871c610148bd5b76e22b2b7544963db66710d6e21a61975f2f5c05706fef9e7c6e25f46a87242fe6c49fd83dd0e7efce54f7e969640448468cb90436c37a8764ae12435a69d079db0c5d94036a7083f3e817fa5ab4bc5de7b822417368e502e311b8f45a438cfa58f8fd1c3d10522911603930dc68cf2538d146b62e8b1d6714193f6ddf79f320731b1d12afff3f3122c8ca3f1944712e95077d2184c39260e20c6a654591fb7b06a31ef2b4bb45cfb512dc8b541a6ccafc4e8e175823bd5517c0beca009587388e9d48168e3e888d965eddf8b01881a3a8f3815e3b4b1335c35f10e10f27222a85ab4dd80cb5d5636621ca08e83fb0687de634aa0078b6226961b0ec7088fa8d66eee3bd4f68d0210b84bf98caf742e3477fbc94695fcde8f13e7fe30ad9670ff72a3568474d6c3366503c37c5de085778f9407c619c6ee512ec725b1d42e6cf24b9e0afe95a94fa464b918095c10816206372c71b47217771fa34bc46a1655a7ca9916b28d14914ba4269cb7c543dab4f263771848863e151d8ef45792baaca13b9ced9b8e63d79cde1c00c7242bde55dc89b4a9785f5c94da81ba4b48911337e9d0f046c6c30ea1c732dd98503a653caf702f4448d6b11eff329dbdc41a4c374a2347e0c7b5729684173ec00b9b37316d2498b2e4fe7f4a2a9fc9247f364d684cec938e7550a81c8ac48067c40e902b18397fec818201703e35662fd10b0dc375a5b2aac54309efe3501104b8b7ccc63cf766add9d38b064c0eb1f735bc7f043ccc35d45eab9a1aad49147f4034a2befd108d6101e3238daeb2b68238da28b81065ca87dff9ead3a9184be98d36e32c28a9fcee58389bdf87e9ce8953b27c60d73a6e1a3e554309a8ea9ff36aab455cafeed1a5c8778bf37ba342e76593d65af9028ea8377c5ae6c5290f5e8a855b39e70778a610d8fd550419aa47b274dd56bf2f379583db0676aa5f202a5bb4ca6a8a111f11f41ec89cb12909c2e7ef6652640fe1df91dec6474bfc664dfb260c6059b5445b87dac590a722571e57e5a87ed3750a0217d1af4af8a00f8b203a848563773c57378421cdb6cb1a010dbe916ecc2733e8a54912b0ed19464686f1457aefbdde3a7cf22e34a73a5ef9e5b4d88d5260372c0179aa13d107317d6f8a2f8791ca8f8e34d7298f89820265d339b3b3bf419830d6350379f811625a3ad5bb2112839a1209ef3d46b0477c4cbc35f2da687a49b528447ab93a3d9644efd0db2102a9b8434440b4a568fb66a55b628e535546542065e067a6d05ae78a768276cb2183d9686b7fc75bf3bc2eb13f2b3b59512a088df11a4f7981ae8f5a2a10cc897e6e568d6e44828f79f88b261eafe6b98ba27fe9741e0778ac306935f2f95e662b64b692372bc576758aaec68112a7d0029ed49e7cc83db097bded8424aa3b6009774c7ee9e58bc075bdfb863a564f3e8c04f2be81ab1924ddc4d2957b28adab89d7466c39d2befaed778353ca1abd820e7d006c501eaa0d5ac6964ea29c85db9d213bec23fb4fab6ac22a4bd444cf58fa074d8357a75b512b7d85e0f1bbc20b0ca53401c915b2cc9e337b4c8c094558193cf4a9548c5035a88385d1499bf363525512ef36011620e468be3f483f75f0094245f79f2d5c4e61637713a852fcdb68e85b6c7a9cee49a81cf803b72c07357ad3f48395b7619a6aa7bbf70d8984aa1fca0591ed1b2c6feedf9ddda39109fc48ca4e8ade5856204b7993ea559bbdca368cca7e59d9ffc1b4f123b50c0244d946d8463917239cf3b3bae32d0f9898220ea30a57fe79dae9f12922a5755f4a9f1defc8d03494f0a04403d7d0973cae4c86169a4ef14b7e3fb07b9428c12f18ffc23262aee73a38dff4a1ca5c2d177e6849ce12b62f5c59de594f159d6c9068d45163e5a093932fd7e7104e2783531bc4694636b3d72997bfdfacda506f42c16dd923f9a7c30b4b9716ab2b91b2e8d062aad8afd9bca4502e8ba9c00030afe68b1d4541f836f14f2914f85cf9389d374eb4c165b3c7792b8fad461a10595b01a9642847b1069316f0f933faf507a63966378ef14b077a4914a29088247b4941395b9bff9191b31961135ccd656276c5da722c7d64347a30829d258baee60a19a2bd849bc55f3241370f74514e36638fb1d0411f4ff6770fe01ecfc67283f73dd9a4bf2e5b04df67d5481371fcc63766b362b9f3b95d24c8f367bb9a0a7e281571d68dbb167492a45accee6e49fdc3c5c9ed9b1acd18f1aa53a173f7c94f17bd4b68cae5e4256bd1224d3022fe98cc4055f90a915b93c58f82d1f48a483e9d6170df54d93c01dfb3920be253e11bf9cdd33d5a0b6cc5557da90787faff9e39e4200ff8c5a70050f2f50c47081d17ba9f571baa21a70ab491be5a5651bdfad0367bb65ff742c31763092489feae0fd8c586447f411fef42c3dde9c14a56132a850a3c98ce62eb4f0fd69be14e870713807a14f8880f337b7ef06ceb105cbe5f795fc5d8e84877443b0f4e050302ac44a86fbfb281a7a8aeac7e885a2581c68d764b169e54dc993eba0ae002c9430f420e6240dffd0e1b1daa7820052813c824944474985e2deec55efa4e83d81897381ac2e53e9b129300db72e02a4b5ddeff77a3b8ca7e19ba746c040ed6611183d122826c0b9460666c0de8b523b7ac4a16cb35fcf2f7f72aac888a5b95bb4eff650340bf69ae083ea026b5767b3771ee1642400bec844c634be2006a9aeb6d48729baaf8f1215263dc0a3ea2cf5ea59c345f4857774180fae5819b2eec14aec02dc5f217883a502aca098eac9ca1917925e2f2b240ec673d724b35662ec9ca2fb55dda64a7293cacb0d6e02f053697987312fa736ce5c688cfe46afb4f095d5b85f2a85d1ecc6b2dae269aa1d651e4353bf47be51a85f13bfcbeb22a8dbc76aff97185c92afec04873a7a4bbfe5b9335b79cdd4337714d9040169924d9d8a9a46a5e595651b801c36399ab0f4092b582445ff8435795dd97a87473b071169b05c5b29f987c4fffacb875f81d082980d5a91c35d653980a8b87df9068de7768ba7276c224e80cff21106f8b459cb02eee781b82834fa805a908083fdac6ebdef51d3bf3a4971d8700c7eb5d9cea26ee335cd38b302e8e1ace72dbdbad525070ff723dc906604e3a335719d8662066e631e962ecf6d1a5ab86475c81d8dc0aa0938ae1cd6d73d78f53433793ddd2d60b4a273ee6100c069873ee9f7c23f289062484c4ac48105442bf57baa487b250b02323b16fe8671fe0aec3d9b4561856ac1e89238b0858d4b1497c1d6b32b256cf9af183b2c6a3156cda1ad63ba71689972a32ba0079d3b6aaaf27ff15c16f9f9fe269495c551b9ecc99db62653f232cda666bb618f832b0d930e60226d55f7f60af771b7e0019adaa5f7023d01713166b79b535a01fe5dfaf3c8aece5a297f7923b3ca943af692810c793d03bac722de3c13e3637a49e2803b6a0b6c4983b59e0a26ba04812b0f2dcefd9c86f9e934b59383234a67364e543c2601f7b4d0b5db7d226890cbe3c245bee1618a4c0581af363b98fcb74ed2759cf573dd6bb1cfa78d52b1e03741a25aafc058556731a2139cc1fc672564491f5414abf9ad822e1a3c40ae75ed6f6bd016942959422c7903a1eb67199b9ef665dd7f01d136733ae61e5d7c25f1049d55c12cae84bfe571f9f5226173fe194ec66270bc6ae1eef0c4d8ac79cb8ddf887f5599c7571527e46776a02e3bdf155207e2264c53af4bfeeef35fc10bb706c2baeaa2742b532ad13cedca0a0843c4d54f4106ea51a38dd42f37e1d6112e20d7bf0c79e8436e6abd25b7fe44927382e1ae98e696e00ec3263a00bd8e01b9ab93cd1ac084ef2c4a66d73e6b0ec800912e022e073dfa86ac719a7820bd0ad4de8c147211ec94569c4dcb97737b9f5787521faa4db7c48ab548b5e421330cd19b55237d895e0fbcecabb0e8601bdede345bd313eea92acfc9ddf24b2e19aecf684aaba498858068c9b9fb8bf0dd5784a2376812c5bd5306accb4dcc50f52fb613c6c4d2192a320e7277e66a3463f289e8accf9c1ef286c2755757a6d1cd25480604cf06d6f79204e84d9411dc83cac77332e12658186582f95440052a7f9a00b30b1a417a91de81353ddcc5462b43e5045f60ae5f56954328d87984b198f68d2a9139442efdafec9fd3cf8a5255031582586cd0b03570ab0305b5de1d35b2e03b60ccffd8d2461625fba0bffbec70c199e8d07ba96d4d92f42941f56cfcf2447551f091c0ed1196a166733bb7656d7d25d86fe28466361ac3366ee5ba47bc28b6ce9cfabb8cb47660be397e509cb11f6173863d0fbdf5248ebfb2e74a5ffa424fcc4aabc0adecd3dc1105fdb39779fe0b2d01103b1186709b6c3a57a709ab8345ee7986aeffb32745a11754aaced5deb8ee791be0f2eff6fbd5dd000141415a43e2284e69e94c1b387c7fc4a137d69c92301bc0758d3a018795ab4dbc0cf530bdda63b69af212a30b4bd0df780350d2da660c2a0fbfd2bd95b9f06fa3389d95a2f882e17768fae63b0a44a16dceaeb9d863ebdb8757eaccce9a67e70ef418df8d885272edb263a04fae99813f56f4c1f56f4bd840dd1b5d1c711149ea731002eb470e01b99da6adc9e689c69e8667118b97fd7abdb86089503a00a955a0d1afac51d42d494874e48d75bd22cb9a6afe711b1049e2d808ee7ab2f72c15e5f744bf76b2c94c456c55a972e5dbe22d767dcd76cdbb36507dd1f71f984035b1f7dda94984b6b2d3a6a545ce75045bc5013218db3ed7db82e37b51bb223a44494672ef7a79cdcbe32cbc047058d93a2587d54f27d7cf34ac133143d06ff847c24a245067fba0823f85a3e534bc0ac9bf9c5b46a49ced90260aea9202302972b773598ad6747149e0e4058781951479dd58d789b4c3380c28a245383ef446b3b687ea1cf3b752c2a835cdcdab4923d2e98e689b4eed10936a7fb33d30ebcb4021bad54da50ff52c66972853a838284d7ab39383f967cd26023fa3ad0e8baae3bae82b8bd795281635e810980249cd2edadb8690dd525fa35e272d1949527efeb365faace9cf11880ac3ebc0ab1818fc5d7da1a57bc95aaea33ef2d58cf77e6eb64151f63d9d7a68eb09f917e27bb674d95c34da2a6b8be80a0ca3caaa870aef188ac0ab4965bd56abe8cdde8952e5e49e2a55cbeec704e79f9f68cb38aeae30f36dae9e814f1e0b99a80e02e5a00c0276dffe12a6618f31a1c9465afb36e52bd5b645161258863158af496cb3ae39faab5f8ad1f7bbb5762c6c0161d6ff1f7204c87983af2d32618615ed462f4719c34c7e5361c226d472ddb228931c47d9cecf9552c656166aa1f507efeb060f3a0c1d64878840ca066cf74e4873b6f02a436def3686c44beecc3405a08f46f78b122e66bf2083cded64d82a01bca4b1b7e540e48d1c966d248625607c23987fb33e92864d1af04a44d797341607115d0b72dc08789cd45d69f09d3d4a45621139aff8230d68a128e2faf369990dbe8ab748ce78df1190697c30a65862baeaf0241e0da58c6a79d1ec48a44d8403e2a755996525f5395d6fc1710cd69301c5b91d00587745a7f26ed021bf3507320ed081c4a3cb821d6292d1856feb0d87a6a4e055cf728bfb35c7ab119fa9050619859f9793ccc68c84ca89661f8bcde3aa10cc2b9113e693a141c8446dba6b5ff002413f7fd5f1d062ab7b2156391d365e73363b1641ceb6cce8ff50d47997e1bf4a42e2e1303a0c87157151fc87a343ac4d2a976e2acf295b31e82b509ecf58e644493aa34fdb6da5a7da0504dac0665fbcc25da5cc0650f84b7bd75c9079e30d6dfd197352fd6f28d7409a90b95f72b436f4736724fc11459faea4e22e89fa79f192e4596d0e7cb40010480628de84df1e0669e4f8c0d52be52bb7ce48c30eaf77a317c429306e3e657a20dfd3146ed46247ddd2e0c6ace1a651cbac4aeaff698cd7be0686b8c2e0db07b30d4dccbdd37dac4fe243b10e153289f6d776ae7c4b46c5c4e76e8d01f703ee684549ba09e0bfbf50df810ff74836f41129758c702098c5ff38b14ece4cb7ffb36669b43a0967fdc523f8c5da73fffb43cb9c2575cb79e262736f2f6f3616d658c20b08ad33a5dd867c06b00e11b40421a5053728c87f7321ef0182877069f737ed6c4f9fc492bd95cc639d73862747ed451e3b2216b93ff4acd06e4a21e0f00c","isRememberEnabled":true,"rememberDurationInDays":"30","staticryptSaltUniqueVariableName":"6c749e522a8c08bc93999f011ff1b2c2"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
