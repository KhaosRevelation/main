<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Leaks OnlyFans</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Leaks OnlyFans</p>
                        <p><p>Pour avoir acc&egrave;s &agrave; cette cat&eacute;gories il vous faut le Vip (ou un grade sup&eacute;rieur).&nbsp;Vous pouvez aller voir les prix sur le lien suivant&nbsp;<a href="https://www.khaosrevelation.site/vip.html">Prix VIP</a></p>

<p>Revenir sur&nbsp;<a href="https://www.khaosrevelation.site/index.html">KhaosRevelation</a></p>
</p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Mot de passe"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="AccÃ©der" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = 
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "template_error",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f80f3964b62d9dfa5669ea2d6f7dc8839967f6b8922aa8fc621dc966645b64bfeb7eb351053f1c57585bf58de5a0476087ad16c67ce45143059f7e9a5a7fbc5aebabc0eb8af4242af6813c95799daf7939cd69038089ad4810373c9d262c4af5a23dd011b1736597ddb10789d6ed3c9aeb1010ffedada30faa9fbb89699db5463ef835f6b0fc7f4f2cb9de636f952f1805122c1d42336e12d0c33df9df4ec25f13bc6999a5c1fa3f74a7683d68f8e1bb4c2b6b28628db8b09a1e3be949ef8ce8b442f66f4fae59389b50cbbdfdb3177c96c64382ba4e2fb6b9832daa3edc18bff623c38f17b9d483f5ce9185bfc070bec805c9856c43e30918600307cd56968f628fd7f6563d2402b1546b804560d81e5356295da5d22639ab249c92329c2f72589a89204738f33577fc6f5e61e36a83a3a6a3fa9f749d6ce96c19f50c85477334d0166c5fec785052a10408ded66d0bf433dc7bd5836ad9f6727dc3a07e9699b8deb47e616106b56862d47eadc6ad8a20ac58c832fd94190a849279395dd280a7b44a2ad08faab0799dadad36f65f1e4d14b3052ffdb6a2d1bb4dd30db8c55b405a27de4323860db070b6baf4bb415213989b5583f3add2ad2549416b6a548fa2771e4ff74bfed33685edaab6bfaa09474ea3f30d4a1c75eb76e015a7bfc6f1793972c478ed44a02345b0009e381b6a8eb772df756b0826f45d6dde65e0bb2a83bfb6584b563b4764b84a99d8ff0ebd2fb60bad469d06340a108e57a198c5f6c0bb69310392495e867da249bff40f9856d765c32247b2da3d5bd2e7e2264f6995d871bf12a9517eddb022195fd4bb0cce8b63392b56dc960cc13d2c1a60a762a2a464e65aa13a710859560a2eceddc5eac6c3bcd3a6f2b9bf58e7b4ed5ec99f0d45ddd4f6d432a80ba57b6133e3ae2abd44d755c8e6ff74515430a0d4aacd342d8d159991c806277cd936db6bcd396d34b81a358af5637922d382c5d599c3dfaa4aa6709f7277c6d6dae32eb2011a81fbf259d27c6d72a083c371781872170c774d264132824263d1abac952c7910ceb36ff8cae8cb130ccfdbd0837d344736a02079b08c822f609483444197e9d52787618f2cc08a237039edbb7729f9bde800de84c585444dd51126eb4edd7aa42aea78e56cbc59848c1663182e273891ac63184c85dac7f87ae7603678b04a199660178b609f1a40a4dd2b8b4cd7c7c2facd00860bfd050189fcc5d7cd01172fb98e3c62483692bfeee8779ff3dfb70e3b6e9dc3ab2c11506820de6356576604226e579a7fd4bad3fe6825bffc14074f5df1579a0f2f45db1eb5620339d229fb6879aa37eb8f6ac8163ba600a99e09f7e48e10e7fe6121ba459ef5d590a5b33d55070534c57188edaa84cbf14e7484b80308fc6c47686e04726b1578a4404723b6c79c5a9c23b2d8f9d65ff0a8a70695c354fbfaa821a9e187324a9a3dcd0085e35be8c67557c4032d07d4bc835389c189944d80c0988e7d20ea13b046b496c42dd4ae9bbacc7b447c5b5804a9a345f49bfb398c6da991308eb1a5e445cf11015c6946c018eda1b90b44ae882f57015a3b9fb22d7170f5ef11b7a6ed7c8b49bee857dd09b9b34964dbd8483c2deac81b40d170cae788c6544d9e5549b20ee75d4ee770f22517582525b47b6d98d065ec42d793a317ed2c626d968cccd20e481bcb5440743dc011f681ab0e97e18b94ce66e1f593a7a252337adebc117d1eb3c3016d0e1cf8ae30256e51847f87c10c49dd0077e25bff11731716b26bdbfe68128f839d0ab627964897a0d98d1729b1f8ae59b2e94308725633560a9129316654665ef918a9c9bc1450369d430d999379f4fa6cdd0302fba2d584b5fd61f3bc6930e28b825b7b6c23a22893f8b5e8f0a59bdcc9cba8028d3a83b8419141ca8f0d5f20368f5f6a5387105f8122ce5108f493d5001e6334d8b4c060b9bba63fc2feb2141d7d1f4ffae91f664d293fd711f70c7a42f413408063386a39e9f9cb98780fb37aa7bf79cffaf8a32d0dd4f20a940685ae54e08e40f2a4f0e37fdee7c9631a5f9d1b0a73b50cded6216a7fa7e37c3cc3e55af0ba3f0e91e989cb49ec03831b16c79c7dee8c96ee0e94a378fa8bb0187c2632fab00e9078d4a109a14b4d5de5021a38d5d9b68933338dada03826b5195c688e11fbf97a73e52d5ac82cb28e12c59db582c99eca555a8b5601f21ef124d28bb0cc4f398f17127d2380db803bc74b762d56b375ca78241c5cbd745c2f3bf7cc65f34476b0d060979f2debb414e23f7411a2fe3ce62dbc0c28b426278f091fcaf9c1c8d036de80d1606a54b5b35e53918350eeda619042ed7e2d77ff1b9a00018803a0de19a8e79156044a07f11887310d2b57bcfa8fc224ea3cdcf98567f0c8c2d2932409135669d379f03b0be153166950e8ea21ffcd5fcc50c0790b8aa984558ca640b2b81a55e94502b5348710097eaa20aa7da90c807e219c0ec993f8687113c021576281f5b8127577119c043a3c33d82695653d97eeb682ae9f2d2e8ab7ec9bf0ffba4900748f553b805adad148d9e77f98c603825e2b92d534176702435354ccce6db9279bc385cabae6325e554bbd2d89ca3f4e1ca2bceadba737b7ef53dd8c819007eeeb2df1d60b99a6b184d7e0c7da4ab3ed3dcca90c2e81c35cf6213ce7c6dc36435108ca5707331d881b78c04959540ca20dae8fead18c8b89bc82f51f97905037016579e3d2accff0ae6af2567117194931def629887f43d34485395c9388b93cbadaea7f4b87c530b5cd9c72e41844baa7e626d60111c3415d4953d7ae1b985b83328ec3ba2542b11d5e96e838a04a089ca0d70cc96eb4a2b074f42e5ff4ffb6531c5a088bbbc74b59230a7352f87973ebffa4a1ddde401c2732fd21d03b7e13cec591203f31670d0848e4a7e19f06ae773372f9e11509d0a6a4cc6b741032f4067c69e600d931355cbde53807cae8d01319d08285c39cc9a3c1b6fc69d3ec578f4f76a0ab36608d34db629c4c5f0c8ddbc02fdb54348564a786632d8b56b79a06a6de3a8123e746c251f4fd1d2169bb593fdf3e755e22fb696f697f24cc543576f4f878cb1c3bd1870798071ca618a6a7ec8ad78a084326d761da704f8c0c953dd7f407c5770dfd46b370a4ad9b9b7a5b8536e98610563a174589a7e299eeb255224c759bec5129b902d9194cbbce1a26bca0e312397cf9a87eb60e13b22a5cce2bcef5385e3e96be9f5035b9ed2bf1fdbde91f007d35470bc42413ca1525cb1f450cc58489b3fe9df1d83620250948eebb0b86eb25dcb71562e41330bb09da79f998a7f0e11480c7d75cb928c3e57a372af98c1bb04fa9b38ab7e334d16ed049204c88333a67c971415b776e757954325d7fa4883cbf7089cb029ca886954ffff99bca226f050d8da04b7533262aa63b3e012dd10ebd8e3335b2ed8675f74bfdd8c8f6cfedc69b5eb7242bc664add12064f16e158608c6e6b9a441f7136b1472f5c88e6b0cec15180963d4b367f6d0dc308f4d457d7230d7240fb5a62190efd90220e13e9a112760556e9d3e6c9c0c40f41d66bf581fb5c233ece451f85795b57bcc9fbd43d85522b266c3b32df752f8975f33b2448ebcb0840e147bdc98af9c08e510c983ed5af45f151d29962952ed96677a579cb570bae9dd476e27bb50757db36e14700726e22718c9d8d3d5dae4cc981bf32b8ebedf516c4c62c2500031e375ad70c9b191d5bae616ac425727a1fe69a7059739f71c810c84df6665ae688245533bcdf7aa8c2154a895090abe2e1aceec186dfb4f957041c0182213b48900115050dda74f8e5f543e34f5c4f61d162cd7410bf6e480846772b10dfbd9e6255b4f6ad797b7ca9f0d3c9966247fd9be7b7967a96abce4e5a39c0aa3e9be1a1f3e08398818f36bd683a0e106935ab2648b8d5885348a47883ba4cdb68a1a4e0ba4e5c044f6a88e54ec2537f60d5813e6f9b1bd9dcac8ac0b9d6d7c2818f5d43621958efaf21388504b812e0c8ce556c75dd3952395197661de5236bcb6dc17eef5e8c6b3977ff7b3fe3dd87a0d5f58da138f4dc1dee48071930d91cbf52100ee1af7f487fdd9c63e0dff7a6eca3b996e41dbf71263513477bcde284623eb8f06eac4855439ceaa13c1a8951661c5afd090bf66d70e55d762189b7aeda46dedb00418d97570bd95ff98c7fad6eda5c6826b45ff31d887dff232ea8777291fa1603c22fc0b5e32a1fc836e11bdda665ad235d1e62238235ab1e09b64506ebee402c26523c2961614a08b736c866b998a2bcbc884a4a2ce75c13e293fe9420a77ac68bdb48786d9ba18fe5dc6ec549d8c148df55987eca46c2b8e495252f5e08d9f971e13c6be4e99b51cc5b684a3e405ed3323ca069899fe458ddf54faee91818350ba7f74ddaf2c378ea7c12af732d5330eac35e040bc5e0ea21cbc31fd4460ce809e5dfe9aa213b51e9facf81c0e3223c331da76cc9c6d120256cd77423c83913bb72a3bf116b01f48b60dee72fb8469352e6d4f481345120b38b63d85b6fcef275f79bfedf95de34cdbe7f065dd6b15be93878bed43f8b0893c8b1aafa9813679fadd75a5cb87e1bdec109129f9aa44e1425cf767402bac2ec228258b07b47047d56c86223b14fe19bde050dd18a53e86b0330efdd214572ab326650cb07fd5c01452db29d4ce75d0f5afe434f95cd934347a15ce82d4c0f5f26e24de8218f11923038460c73712e9c6585db4c4eb1704ccb9b00a9ae31316156d62aa0be41a32cabb26eaca0573f50d9108f076e91241ce55055717920237b6d65b350ac388a99c0fe00bd1757e9ce7d0f31a2e93c67e0f88cc6f5f9a2d952dd457c1d73baa6164ef8d387beb54988ab93d84d101b23c45cd0836f72f52d8fbbb19d283924d2ccc2ce97ede7aa5ce286a9839445e665cd31e0f818b307cca8ba389ba80057fb9aac136c38aa7b5f6ed66a79308e69805083e68c8e9449e745ff0210930a73c70d8c469b9f02fa13d4353925dddaa0874dcb775f7c208100115315f42bf4805a65b353e6c9c0b98eb92200a07a4a0ea62bd20dde835e171c8a672a5341613185fcf95210366d7ddc2b322ef489cc22a7ba54e48811820adcf02ef10b4ab1b85901a8de0ca100829bb5df7732a2e675564e122975c321a204f0ae94dd119d8c17c804dbaa75296bff647b660da7380a04c07ac1be804805008abbc4486b463c490f751e6720d05b7cd590a0ca7ef1dd4e104335d1ca855f88e643bc82f2cd66e7f174ffcc21dd5532d4a1ba8225158d978a56410a9a565cabb25a24273807173a29c87d79a0ac3275076d83529f16b8c36cc17078ee4cdbac69bb3b4a2493800e6d0a98aba23c96d4a34e2aebd55e1d2596d493a78858c8d3c034aa3bf18fc883f71e700bc14ccd764ac36194ed3eb87b7cddfeb26bbd9c2eae98804ca96f6405985275ce6bed0e1705fd7e491d5be5a677ef122f8ac2666d45020d457ddd9a28ab61483f32cba5101af11b04678a9cfad4f2b800739fb280666db4226140ba6a0eedf25517c73b0c45933700c29dec2d9cac4f74638420a1e17b9cdb24210b2e1074f20fe4bc00db1eb6e18dd48057e2515aea72e0cbff4015a8500c4caca7ea1a83aa3d5438538b9436b933d660648282847afb9380aba5a98f5e100967fc86502a4b1a89dc5e4b670cfa46e82c285817cafb3e7b86b80450813b78d25caf52888f42f796a052516c70c9f71cb6e7dd76c8743d68405d590680d690f71a8c0a91a9eabeecf01cb4f70f4f509c6cbdcad93806f00764285b5ef2a7f2b65430150192eb6d218edb40d28d37bbce3883386f803a8ae0c90b66e1d0f511fcc0edb8db07e5d5677de40e912aa3c66b6027d1e26aa87185a97e34434366f677dd60ab382663e62d818b59cae95e01b68f68bb3c3fa4f77a1264b17d6277cadbcbd1fcbd9abf97fbc41d3e2c740b70348905a57a604bda5fdcc52b01bcc49c92efab1638b5f2e7e8c4515b7338d4fdbd835a3676380d73f985ace4d190857f7651cdc7c5d9b7ecedd5c51e7732595bfc3f0088823923cd2fd7e70e4b4be71842bed1e80a3486f6dd665f2163a4b852f9599c8ba6b8a0f4d5b4298b6b8febf003db088f5fdb23215f70df53011f49264665a6f5b3d4201","isRememberEnabled":true,"rememberDurationInDays":"30","staticryptSaltUniqueVariableName":"7be0b0e4a36f8c5d12021bf7b710a5e3"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
